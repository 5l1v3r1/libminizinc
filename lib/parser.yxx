/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */

/*
 *  Main authors:
 *     Guido Tack <guido.tack@monash.edu>
 */

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

%pure-parser
%parse-param {void *parm}
%lex-param {void* YYLEX_PARAM}
%{
#define YYPARSE_PARAM parm
#define YYLEX_PARAM static_cast<ParserState*>(parm)->yyscanner
#include <iostream>
#include <fstream>
#include <map>
#include <cerrno>

namespace MiniZinc{ class Location; }
#define YYLTYPE MiniZinc::Location
#define YYLTYPE_IS_DECLARED 1
#define YYLTYPE_IS_TRIVIAL 0

#include <minizinc/parser.hh>

using namespace std;
using namespace MiniZinc;

#define YYLLOC_DEFAULT(Current, Rhs, N) \
  Current.filename = Rhs[1].filename; \
  Current.first_line = Rhs[1].first_line; \
  Current.first_column = Rhs[1].first_column; \
  Current.last_line = Rhs[N].last_line; \
  Current.last_column = Rhs[N].last_column;

int yyparse(void*);
int yylex(YYSTYPE*, YYLTYPE*, void* scanner);
int yylex_init (void** scanner);
int yylex_destroy (void* scanner);
int yyget_lineno (void* scanner);
void yyset_extra (void* user_defined ,void* yyscanner );

extern int yydebug;

void yyerror(YYLTYPE* location, void* parm, const string& str) {
  ParserState* pp = static_cast<ParserState*>(parm);
  Model* m = pp->model;
  while (m->parent() != NULL) {
    m = m->parent();
    pp->err << "(included from file '" << m->filename() << "')" << endl;
  }
  pp->err << "In file " << location->filename << ", line "
          << location->first_line << ":" << endl;
  pp->printCurrentLine();
  for (int i=0; i<location->first_column-1; i++)
    pp->err << " ";
  for (int i=location->first_column; i<=location->last_column; i++)
    pp->err << "^";
  pp->err << std::endl << "Error: " << str << std::endl << std::endl;
  pp->hadError = true;
}

bool notInDatafile(YYLTYPE* location, void* parm, const string& item) {
  ParserState* pp = static_cast<ParserState*>(parm);
  if (pp->isDatafile) {
    yyerror(location,parm,item+" item not allowed in data file");
    return false;
  }
  return true;
}

void filepath(const string& f, string& dirname, string& basename) {
  dirname = ""; basename = f;
  for (size_t p=basename.find_first_of('/');
       p!=string::npos;
       dirname+=basename.substr(0,p+1),
       basename=basename.substr(p+1),
       p=basename.find_first_of('/')
       ) {}
}

// fastest way to read a file into a string (especially big files)
// see: http://insanecoding.blogspot.be/2011/11/how-to-read-in-file-in-c.html
std::string get_file_contents(std::ifstream &in)
{
  //std::ifstream in(filename, std::ios::in | std::ios::binary);
  if (in)
  {
    std::string contents;
    in.seekg(0, std::ios::end);
    contents.resize(in.tellg());
    in.seekg(0, std::ios::beg);
    in.read(&contents[0], contents.size());
    in.close();
    return(contents);
  }
  throw(errno);
}

namespace MiniZinc {

  Model* parseFromString(const string& text,
                         const string& filename,
                         const vector<string>& ip,
                         bool ignoreStdlib,
                         ostream& err) {
    GCLock lock;

    vector<string> includePaths;
    for (unsigned int i=0; i<ip.size(); i++)
      includePaths.push_back(ip[i]);

    vector<pair<string,Model*> > files;
    map<string,Model*> seenModels;

    Model* model = new Model();
    model->_filename = ASTString(filename);

    if (!ignoreStdlib) {
      Model* stdlib = new Model;
      stdlib->_filename = ASTString("stdlib.mzn");
      files.push_back(pair<string,Model*>("./",stdlib));
      seenModels.insert(pair<string,Model*>("stdlib.mzn",stdlib));
      IncludeI* stdlibinc = new IncludeI(Location(),stdlib->_filename);
      stdlibinc->m(stdlib,true);
      model->addItem(stdlibinc);

      Model* builtins = new Model;
      ASTString bn("builtins.mzn");
      builtins->_filename = bn;
      files.push_back(pair<string,Model*>("./",builtins));
      seenModels.insert(pair<string,Model*>("builtins.mzn",builtins));
      IncludeI* builtinsinc = new IncludeI(Location(),builtins->_filename);
      builtinsinc->m(builtins,true);
      model->addItem(builtinsinc);
    }

    model->_filepath = ASTString(filename);
    bool isFzn = (filename.compare(filename.length()-4,4,".fzn")==0);
    isFzn |= (filename.compare(filename.length()-4,4,".ozn")==0);
    isFzn |= (filename.compare(filename.length()-4,4,".szn")==0);
    ParserState pp(filename,text, err, files, seenModels, model, false, isFzn);
    yylex_init(&pp.yyscanner);
    yyset_extra(&pp, pp.yyscanner);
    yyparse(&pp);
    if (pp.yyscanner)
    yylex_destroy(pp.yyscanner);
    if (pp.hadError) {
      goto error;
    }

    while (!files.empty()) {
      pair<string,Model*>& np = files.back();
      string parentPath = np.first;
      Model* m = np.second;
      files.pop_back();
      string f(m->_filename.str());

      for (Model* p=m->_parent; p; p=p->_parent) {
        if (f == p->_filename.c_str()) {
          err << "Error: cyclic includes: " << std::endl;
          for (Model* pe=m; pe; pe=pe->_parent) {
            err << "  " << pe->_filename << std::endl;
          }
          goto error;
        }
      }
      ifstream file;
      string fullname;
      if (parentPath=="") {
        fullname = filename;
        file.open(fullname.c_str());
      } else {
        includePaths.push_back(parentPath);
        for (unsigned int i=0; i<includePaths.size(); i++) {
          fullname = includePaths[i]+f;
          file.open(fullname.c_str());
          if (file.is_open())
            break;
        }
        includePaths.pop_back();
      }
      if (!file.is_open()) {
        err << "Error: cannot open file '" << f << "'." << endl;
        goto error;
      }
      std::string s = get_file_contents(file);

      m->_filepath = ASTString(fullname);
      bool isFzn = (fullname.compare(fullname.length()-4,4,".fzn")==0);
      isFzn |= (fullname.compare(fullname.length()-4,4,".ozn")==0);
      isFzn |= (fullname.compare(fullname.length()-4,4,".szn")==0);
      ParserState pp(fullname,s, err, files, seenModels, m, false, isFzn);
      yylex_init(&pp.yyscanner);
      yyset_extra(&pp, pp.yyscanner);
      yyparse(&pp);
      if (pp.yyscanner)
      yylex_destroy(pp.yyscanner);
      if (pp.hadError) {
        goto error;
      }
    }

    return model;
  error:
    for (unsigned int i=0; i<files.size(); i++)
      delete files[i].second;
    return NULL;
  }

  Model* parse(const string& filename,
               const vector<string>& datafiles,
               const vector<string>& ip,
               bool ignoreStdlib,
               ostream& err) {
    GCLock lock;
    string fileDirname; string fileBasename;
    filepath(filename, fileDirname, fileBasename);

    vector<string> includePaths;
    for (unsigned int i=0; i<ip.size(); i++)
      includePaths.push_back(ip[i]);
    
    vector<pair<string,Model*> > files;
    map<string,Model*> seenModels;
    
    Model* model = new Model();
    model->_filename = ASTString(fileBasename);

    if (!ignoreStdlib) {
      Model* stdlib = new Model;
      stdlib->_filename = ASTString("stdlib.mzn");
      files.push_back(pair<string,Model*>("./",stdlib));
      seenModels.insert(pair<string,Model*>("stdlib.mzn",stdlib));
      Location stdlibloc;
      stdlibloc.filename=ASTString(filename);
      IncludeI* stdlibinc = 
        new IncludeI(stdlibloc,stdlib->_filename);
      stdlibinc->m(stdlib,true);
      model->addItem(stdlibinc);

      Model* builtins = new Model;
      ASTString bn("builtins.mzn");
      builtins->_filename = bn;
      files.push_back(pair<string,Model*>("./",builtins));
      seenModels.insert(pair<string,Model*>("builtins.mzn",builtins));
      Location builtinsloc;
      builtinsloc.filename=ASTString(filename);
      IncludeI* builtinsinc = 
        new IncludeI(builtinsloc,builtins->_filename);
      builtinsinc->m(builtins,true);
      model->addItem(builtinsinc);
    }
    
    files.push_back(pair<string,Model*>("",model));
        
    while (!files.empty()) {
      pair<string,Model*>& np = files.back();
      string parentPath = np.first;
      Model* m = np.second;
      files.pop_back();
      string f(m->_filename.str());
            
      for (Model* p=m->_parent; p; p=p->_parent) {
        if (f == p->_filename.c_str()) {
          err << "Error: cyclic includes: " << std::endl;
          for (Model* pe=m; pe; pe=pe->_parent) {
            err << "  " << pe->_filename << std::endl;
          }
          goto error;
        }
      }
      ifstream file;
      string fullname;
      if (parentPath=="") {
        fullname = filename;
        file.open(fullname.c_str());
      } else {
        includePaths.push_back(parentPath);
        for (unsigned int i=0; i<includePaths.size(); i++) {
          fullname = includePaths[i]+f;
          file.open(fullname.c_str());
          if (file.is_open())
            break;
        }
        includePaths.pop_back();
      }
      if (!file.is_open()) {
        err << "Error: cannot open file '" << f << "'." << endl;
        goto error;
      }
      std::string s = get_file_contents(file);

      m->_filepath = ASTString(fullname);
      bool isFzn = (fullname.compare(fullname.length()-4,4,".fzn")==0);
      isFzn |= (fullname.compare(fullname.length()-4,4,".ozn")==0);
      isFzn |= (fullname.compare(fullname.length()-4,4,".szn")==0);
      ParserState pp(fullname,s, err, files, seenModels, m, false, isFzn);
      yylex_init(&pp.yyscanner);
      yyset_extra(&pp, pp.yyscanner);
      yyparse(&pp);
      if (pp.yyscanner)
        yylex_destroy(pp.yyscanner);
      if (pp.hadError) {
        goto error;
      }
    }
    
    for (unsigned int i=0; i<datafiles.size(); i++) {
      string f = datafiles[i];
      std::ifstream file;
      file.open(f.c_str());
      if (!file.is_open()) {
        err << "Error: cannot open data file '" << f << "'." << endl;
        goto error;
      }
      std::string s = get_file_contents(file);

      ParserState pp(f, s, err, files, seenModels, model, true, false);
      yylex_init(&pp.yyscanner);
      yyset_extra(&pp, pp.yyscanner);
      yyparse(&pp);
      if (pp.yyscanner)
        yylex_destroy(pp.yyscanner);
      if (pp.hadError) {
        goto error;
      }
    }
    
    return model;
  error:
    for (unsigned int i=0; i<files.size(); i++)
      delete files[i].second;
    return NULL;
  }
}

%}

%union { long long int iValue; char* sValue; bool bValue; double dValue;
         MiniZinc::Item* item;
         MiniZinc::VarDecl* vardeclexpr;
         std::vector<MiniZinc::VarDecl*>* vardeclexpr_v;
         MiniZinc::TypeInst* tiexpr;
         std::vector<MiniZinc::TypeInst*>* tiexpr_v;
         MiniZinc::Expression* expression;
         std::vector<MiniZinc::Expression*>* expression_v;
         std::vector<std::vector<MiniZinc::Expression*> >* expression_vv;
         MiniZinc::Generator* generator;
         std::vector<MiniZinc::Generator>* generator_v;
         std::vector<std::string>* string_v;
         std::pair<std::vector<MiniZinc::Expression*>,
                   MiniZinc::Expression*>* expression_p;
         MiniZinc::Generators* generators;
       }

%locations
%error-verbose

%initial-action
{
  @$.filename = static_cast<ParserState*>(parm)->model->filepath();
}

%token <iValue> MZN_INTEGER_LITERAL MZN_BOOL_LITERAL
%token <dValue> MZN_FLOAT_LITERAL
%token <sValue> MZN_IDENTIFIER MZN_QUOTED_IDENTIFIER MZN_STRING_LITERAL MZN_TI_IDENTIFIER

%token MZN_VAR MZN_PAR MZN_SVAR

%token MZN_ABSENT
%token MZN_ANN
%token MZN_ANNOTATION
%token MZN_ANY
%token MZN_ARRAY
%token MZN_BOOL
%token MZN_CASE
%token MZN_CONSTRAINT
%token MZN_DEFAULT 
%token MZN_ELSE
%token MZN_ELSEIF
%token MZN_ENDIF
%token MZN_ENUM
%token MZN_FLOAT
%token MZN_FUNCTION
%token MZN_IF
%token MZN_INCLUDE
%token MZN_INT
%token MZN_LET
%token MZN_LIST
%token <bValue> MZN_MAXIMIZE
%token <bValue> MZN_MINIMIZE
%token MZN_OF
%token MZN_OPT
%token MZN_SATISFY
%token MZN_OUTPUT
%token MZN_PREDICATE
%token MZN_RECORD
%token MZN_SET
%token MZN_SOLVE
%token MZN_STRING
%token MZN_TEST
%token MZN_THEN
%token MZN_TUPLE
%token MZN_TYPE
%token MZN_UNDERSCORE
%token MZN_VARIANT_RECORD
%token MZN_WHERE

%token MZN_LEFT_BRACKET
%token MZN_LEFT_2D_BRACKET
%token MZN_RIGHT_BRACKET
%token MZN_RIGHT_2D_BRACKET

%token UNKNOWN_CHAR

// Used to signal an error when parsing a MiniZinc file
// that contains identifiers starting with _
%token FLATZINC_IDENTIFIER

%right PREC_ANNO
%left MZN_EQUIV
%left MZN_IMPL MZN_RIMPL
%left MZN_OR MZN_XOR
%left MZN_AND
%nonassoc MZN_LE MZN_GR MZN_LQ MZN_GQ MZN_EQ MZN_NQ
%nonassoc MZN_IN MZN_SUBSET MZN_SUPERSET
%left MZN_UNION MZN_DIFF MZN_SYMDIFF
%nonassoc MZN_DOTDOT
%left MZN_PLUS MZN_MINUS
%left MZN_MULT MZN_DIV MZN_IDIV MZN_MOD MZN_INTERSECT
%nonassoc MZN_NOT
%right MZN_PLUSPLUS
%left MZN_QUOTED_IDENTIFIER
%left MZN_COLONCOLON

%token MZN_EQUIV_QUOTED
%token MZN_IMPL_QUOTED MZN_RIMPL_QUOTED
%token MZN_OR_QUOTED MZN_XOR_QUOTED
%token MZN_AND_QUOTED
%token MZN_LE_QUOTED MZN_GR_QUOTED MZN_LQ_QUOTED MZN_GQ_QUOTED MZN_EQ_QUOTED MZN_NQ_QUOTED
%token MZN_IN_QUOTED MZN_SUBSET_QUOTED MZN_SUPERSET_QUOTED
%token MZN_UNION_QUOTED MZN_DIFF_QUOTED MZN_SYMDIFF_QUOTED
%token MZN_DOTDOT_QUOTED
%token MZN_PLUS_QUOTED MZN_MINUS_QUOTED
%token MZN_MULT_QUOTED MZN_DIV_QUOTED MZN_IDIV_QUOTED MZN_MOD_QUOTED MZN_INTERSECT_QUOTED
%token MZN_NOT_QUOTED
%token MZN_COLONCOLON_QUOTED
%token MZN_PLUSPLUS_QUOTED

%type <item> item include_item vardecl_item assign_item constraint_item solve_item output_item predicate_item annotation_item function_item

%type <vardeclexpr> ti_expr_and_id ti_expr_and_id_or_anon let_vardecl_item
%type <vardeclexpr_v> params params_list params_list_head
%type <tiexpr> ti_expr base_ti_expr base_ti_expr_tail
%type <tiexpr_v> ti_expr_list ti_expr_list_head

%type <expression> expr expr_atom_head
%type <expression> set_expr
%type <expression> simple_array_literal simple_array_literal_2d simple_array_comp if_then_else_expr call_expr quoted_op_call let_expr operation_item_tail set_literal set_comp

%type <expression_v> expr_list expr_list_head array_access_tail elseif_list let_vardecl_item_list
%type <expression_vv> simple_array_literal_2d_list

%type <generators> comp_tail
%type <generator> generator
%type <generator_v> generator_list generator_list_head
%type <string_v> id_list id_list_head

%type <expression_p> comp_or_expr

%type <expression_v> annotations ne_annotations

%type <iValue> quoted_op

%type <sValue> id_or_quoted_op

%type <bValue> opt_opt

%%

/********************************/
/* main goal and item lists     */
/********************************/

model : item_list

item_list :
      /* empty */
    | item_list_head semi_or_none

item_list_head:
      item
      {
        ParserState* pp = static_cast<ParserState*>(parm);
        pp->model->addItem($1);
      }
    | item_list_head ';' item
      {
        ParserState* pp = static_cast<ParserState*>(parm);
        pp->model->addItem($3);
      }

semi_or_none : | ';'

item :
      include_item
      { $$=notInDatafile(&@$,parm,"include") ? $1 : NULL; }
    | vardecl_item
      { $$=notInDatafile(&@$,parm,"variable declaration") ? $1 : NULL; }
    | assign_item
    | constraint_item
      { $$=notInDatafile(&@$,parm,"constraint") ? $1 : NULL; }
    | solve_item
      { $$=notInDatafile(&@$,parm,"solve") ? $1 : NULL; }
    | output_item
      { $$=notInDatafile(&@$,parm,"output") ? $1 : NULL; }
    | predicate_item
      { $$=notInDatafile(&@$,parm,"predicate") ? $1 : NULL; }
    | function_item
      { $$=notInDatafile(&@$,parm,"predicate") ? $1 : NULL; }
    | annotation_item
      { $$=notInDatafile(&@$,parm,"annotation") ? $1 : NULL; }

include_item :
      MZN_INCLUDE MZN_STRING_LITERAL
      { ParserState* pp = static_cast<ParserState*>(parm);
        map<string,Model*>::iterator ret = pp->seenModels.find($2);
        IncludeI* ii = new IncludeI(@$,ASTString($2));
        $$ = ii;
        if (ret == pp->seenModels.end()) {
          Model* im = new Model;
          im->setParent(pp->model);
          im->setFilename($2);
          string fpath, fbase; filepath(pp->filename, fpath, fbase);
          if (fpath=="")
            fpath="./";
          pair<string,Model*> pm(fpath, im);
          pp->files.push_back(pm);
          ii->m(im);
          pp->seenModels.insert(pair<string,Model*>($2,im));
        } else {
          ii->m(ret->second, false);
        }
        free($2);
      }

vardecl_item :
      ti_expr_and_id annotations
      { if ($2) $1->addAnnotations(*$2);
        $$ = new VarDeclI(@$,$1);
        delete $2;
      }
    | ti_expr_and_id annotations MZN_EQ expr
      { $1->e($4);
        if ($2) $1->addAnnotations(*$2);
        $$ = new VarDeclI(@$,$1);
        delete $2;
      }

assign_item :
      MZN_IDENTIFIER MZN_EQ expr
      { $$ = new AssignI(@$,$1,$3);
        free($1);
      }

constraint_item :
      MZN_CONSTRAINT expr
      { $$ = new ConstraintI(@$,$2);}

solve_item :
      MZN_SOLVE annotations MZN_SATISFY
      { $$ = SolveI::sat(@$);
        if ($2) $$->cast<SolveI>()->ann().add(*$2);
        delete $2;
      }
    | MZN_SOLVE annotations MZN_MINIMIZE expr
      { $$ = SolveI::min(@$,$4);
        if ($2) $$->cast<SolveI>()->ann().add(*$2);
        delete $2;
      }
    | MZN_SOLVE annotations MZN_MAXIMIZE expr
      { $$ = SolveI::max(@$,$4);
        if ($2) $$->cast<SolveI>()->ann().add(*$2);
        delete $2;
      }

output_item :
      MZN_OUTPUT expr
      { $$ = new OutputI(@$,$2);}

predicate_item :
        MZN_PREDICATE MZN_IDENTIFIER params annotations operation_item_tail
      { $$ = new FunctionI(@$,$2,new TypeInst(@$,
                           Type::varbool()),*$3,$5);
        if ($4) $$->cast<FunctionI>()->ann().add(*$4);
        free($2);
        delete $3;
        delete $4;
      }
      | MZN_TEST MZN_IDENTIFIER params annotations operation_item_tail
      { $$ = new FunctionI(@$,$2,new TypeInst(@$,
                           Type::parbool()),*$3,$5);
        if ($4) $$->cast<FunctionI>()->ann().add(*$4);
        free($2);
        delete $3;
        delete $4;
      }

function_item :
        MZN_FUNCTION ti_expr ':' id_or_quoted_op params annotations operation_item_tail
      { $$ = new FunctionI(@$,$4,$2,*$5,$7);
        if ($6) $$->cast<FunctionI>()->ann().add(*$6);
        free($4);
        delete $5;
        delete $6;
      }
      | ti_expr ':' MZN_IDENTIFIER '(' params_list ')' annotations operation_item_tail
      { $$ = new FunctionI(@$,$3,$1,*$5,$8);
        if ($7) $$->cast<FunctionI>()->ann().add(*$7);
        free($3);
        delete $5;
        delete $7;
      }

annotation_item :
        MZN_ANNOTATION MZN_IDENTIFIER params
      {
        TypeInst* ti=new TypeInst(@1,Type::ann());
        if ($3->empty()) {
          VarDecl* vd = new VarDecl(@$,ti,$2);
          $$ = new VarDeclI(@$,vd);
        } else {
          $$ = new FunctionI(@$,$2,ti,*$3,NULL);
        }
        free($2);
        delete $3;
      }
    | MZN_ANNOTATION MZN_IDENTIFIER params MZN_EQ expr
      { TypeInst* ti=new TypeInst(@1,Type::ann());
        $$ = new FunctionI(@$,$2,ti,*$3,$5);
        delete $3;
      }

operation_item_tail :
      /*empty*/
      { $$=NULL; }
    | MZN_EQ expr
      { $$=$2; }

params :
      /* empty */
      { $$=new vector<VarDecl*>(); }
    | '(' params_list ')'
      { $$=$2; }
    | '(' error ')'
      { $$=new vector<VarDecl*>(); }

params_list : params_list_head comma_or_none
      { $$=$1; }

params_list_head :
      ti_expr_and_id_or_anon
      { $$=new vector<VarDecl*>();
        $1->toplevel(false);
        $$->push_back($1); }
    | params_list_head ',' ti_expr_and_id_or_anon
      { $$=$1;
        $3->toplevel(false);
        $1->push_back($3); }

comma_or_none : | ','

ti_expr_and_id_or_anon :
      ti_expr_and_id
      { $$=$1; }
    | ti_expr
      { $$=new VarDecl(@$, $1, ""); }
    
ti_expr_and_id :
      ti_expr ':' MZN_IDENTIFIER
      { $$ = new VarDecl(@$, $1, $3);
        free($3);
      }

ti_expr_list : ti_expr_list_head comma_or_none
      { $$=$1; }

ti_expr_list_head :
      ti_expr
      { $$=new vector<TypeInst*>(); $$->push_back($1); }
    | ti_expr_list_head ',' ti_expr
      { $$=$1; $1->push_back($3); }

ti_expr :
      base_ti_expr
    | MZN_ARRAY MZN_LEFT_BRACKET ti_expr_list MZN_RIGHT_BRACKET MZN_OF base_ti_expr
      {
        $$ = $6;
        $$->setRanges(*$3);
        delete $3;
      }
    | MZN_LIST MZN_OF base_ti_expr
      {
        $$ = $3;
        std::vector<TypeInst*> ti(1);
        ti[0] = new TypeInst(@$,Type::parint());
        $$->setRanges(ti);
      }

base_ti_expr :
      base_ti_expr_tail
      { $$ = $1;
      }
    | MZN_OPT base_ti_expr_tail
      { $$ = $2;
        Type tt = $$->type();
        tt._ot = Type::OT_OPTIONAL;
        $$->type(tt);
      }
    | MZN_PAR opt_opt base_ti_expr_tail
      { $$ = $3;
        if ($2) {
          Type tt = $$->type();
          tt._ot = Type::OT_OPTIONAL;
          $$->type(tt);
        }
      }
    | MZN_VAR opt_opt base_ti_expr_tail
      { $$ = $3;
        Type tt = $$->type();
        tt._ti = Type::TI_VAR;
        if ($2) tt._ot = Type::OT_OPTIONAL;
        $$->type(tt);
      }
    | opt_opt MZN_SET MZN_OF base_ti_expr_tail
      { $$ = $4;
        Type tt = $$->type();
        tt._st = Type::ST_SET;
        if ($1) tt._ot = Type::OT_OPTIONAL;
        $$->type(tt);
      }
    | MZN_PAR opt_opt MZN_SET MZN_OF base_ti_expr_tail
      { $$ = $5;
        Type tt = $$->type();
        tt._st = Type::ST_SET;
        if ($2) tt._ot = Type::OT_OPTIONAL;
        $$->type(tt);
      }
    | MZN_VAR opt_opt MZN_SET MZN_OF base_ti_expr_tail
      { $$ = $5;
        Type tt = $$->type();
        tt._ti = Type::TI_VAR;
        tt._st = Type::ST_SET;
        if ($2) tt._ot = Type::OT_OPTIONAL;
        $$->type(tt);
      }

opt_opt:
      /* nothing */
      { $$ = false; }
    | MZN_OPT
      { $$ = true; }

base_ti_expr_tail :
      MZN_INT
      { $$ = new TypeInst(@$,Type::parint()); }
    | MZN_BOOL
      { $$ = new TypeInst(@$,Type::parbool()); }
    | MZN_FLOAT
      { $$ = new TypeInst(@$,Type::parfloat()); }
    | MZN_STRING
      { $$ = new TypeInst(@$,Type::parstring()); }
    | MZN_ANN
      { $$ = new TypeInst(@$,Type::ann()); }
    | set_expr
      { $$ = new TypeInst(@$,Type(),$1); }
    | MZN_TI_IDENTIFIER
      { $$ = new TypeInst(@$,Type::top(),
                         new TIId(@$, $1));
        free($1);
      }

expr_list : expr_list_head comma_or_none

expr_list_head :
      expr
      { $$=new std::vector<MiniZinc::Expression*>; $$->push_back($1); }
    | expr_list_head ',' expr
      { $$=$1; $$->push_back($3); }

///

set_expr :
      expr_atom_head
    | set_expr MZN_COLONCOLON expr_atom_head
      { $1->addAnnotation($3); $$=$1; }
    | set_expr MZN_UNION set_expr
      { $$=new BinOp(@$, $1, BOT_UNION, $3); }
    | set_expr MZN_DIFF set_expr
      { $$=new BinOp(@$, $1, BOT_DIFF, $3); }
    | set_expr MZN_SYMDIFF set_expr
      { $$=new BinOp(@$, $1, BOT_SYMDIFF, $3); }
    | set_expr MZN_DOTDOT set_expr
      { $$=new BinOp(@$, $1, BOT_DOTDOT, $3); }
    | MZN_DOTDOT_QUOTED '(' expr ',' expr ')'
      { $$=new BinOp(@$, $3, BOT_DOTDOT, $5); }
    | set_expr MZN_INTERSECT set_expr
      { $$=new BinOp(@$, $1, BOT_INTERSECT, $3); }
    | set_expr MZN_PLUSPLUS set_expr
      { $$=new BinOp(@$, $1, BOT_PLUSPLUS, $3); }
    | set_expr MZN_PLUS set_expr
      { $$=new BinOp(@$, $1, BOT_PLUS, $3); }
    | set_expr MZN_MINUS set_expr
      { $$=new BinOp(@$, $1, BOT_MINUS, $3); }
    | set_expr MZN_MULT set_expr
      { $$=new BinOp(@$, $1, BOT_MULT, $3); }
    | set_expr MZN_DIV set_expr
      { $$=new BinOp(@$, $1, BOT_DIV, $3); }
    | set_expr MZN_IDIV set_expr
      { $$=new BinOp(@$, $1, BOT_IDIV, $3); }
    | set_expr MZN_MOD set_expr
      { $$=new BinOp(@$, $1, BOT_MOD, $3); }
    | set_expr MZN_QUOTED_IDENTIFIER set_expr
      { vector<Expression*> args;
        args.push_back($1); args.push_back($3);
        $$=new Call(@$, $2, args);
        free($2);
      }
    | MZN_PLUS set_expr %prec MZN_NOT
      { $$=new UnOp(@$, UOT_PLUS, $2); }
    | MZN_MINUS set_expr %prec MZN_NOT
      { $$=new UnOp(@$, UOT_MINUS, $2); }

///

expr :
      expr_atom_head
    | expr MZN_COLONCOLON expr_atom_head
      { $1->addAnnotation($3); $$=$1; }
    | expr MZN_EQUIV expr
      { $$=new BinOp(@$, $1, BOT_EQUIV, $3); }
    | expr MZN_IMPL expr
      { $$=new BinOp(@$, $1, BOT_IMPL, $3); }
    | expr MZN_RIMPL expr
      { $$=new BinOp(@$, $1, BOT_RIMPL, $3); }
    | expr MZN_OR expr
      { $$=new BinOp(@$, $1, BOT_OR, $3); }
    | expr MZN_XOR expr
      { $$=new BinOp(@$, $1, BOT_XOR, $3); }
    | expr MZN_AND expr
      { $$=new BinOp(@$, $1, BOT_AND, $3); }
    | expr MZN_LE expr
      { $$=new BinOp(@$, $1, BOT_LE, $3); }
    | expr MZN_GR expr
      { $$=new BinOp(@$, $1, BOT_GR, $3); }
    | expr MZN_LQ expr
      { $$=new BinOp(@$, $1, BOT_LQ, $3); }
    | expr MZN_GQ expr
      { $$=new BinOp(@$, $1, BOT_GQ, $3); }
    | expr MZN_EQ expr
      { $$=new BinOp(@$, $1, BOT_EQ, $3); }
    | expr MZN_NQ expr
      { $$=new BinOp(@$, $1, BOT_NQ, $3); }
    | expr MZN_IN expr
      { $$=new BinOp(@$, $1, BOT_IN, $3); }
    | expr MZN_SUBSET expr
      { $$=new BinOp(@$, $1, BOT_SUBSET, $3); }
    | expr MZN_SUPERSET expr
      { $$=new BinOp(@$, $1, BOT_SUPERSET, $3); }
    | expr MZN_UNION expr
      { $$=new BinOp(@$, $1, BOT_UNION, $3); }
    | expr MZN_DIFF expr
      { $$=new BinOp(@$, $1, BOT_DIFF, $3); }
    | expr MZN_SYMDIFF expr
      { $$=new BinOp(@$, $1, BOT_SYMDIFF, $3); }
    | expr MZN_DOTDOT expr
      { $$=new BinOp(@$, $1, BOT_DOTDOT, $3); }
    | MZN_DOTDOT_QUOTED '(' expr ',' expr ')'
      { $$=new BinOp(@$, $3, BOT_DOTDOT, $5); }
    | expr MZN_INTERSECT expr
      { $$=new BinOp(@$, $1, BOT_INTERSECT, $3); }
    | expr MZN_PLUSPLUS expr
      { $$=new BinOp(@$, $1, BOT_PLUSPLUS, $3); }
    | expr MZN_PLUS expr
      { $$=new BinOp(@$, $1, BOT_PLUS, $3); }
    | expr MZN_MINUS expr
      { $$=new BinOp(@$, $1, BOT_MINUS, $3); }
    | expr MZN_MULT expr
      { $$=new BinOp(@$, $1, BOT_MULT, $3); }
    | expr MZN_DIV expr
      { $$=new BinOp(@$, $1, BOT_DIV, $3); }
    | expr MZN_IDIV expr
      { $$=new BinOp(@$, $1, BOT_IDIV, $3); }
    | expr MZN_MOD expr
      { $$=new BinOp(@$, $1, BOT_MOD, $3); }
    | expr MZN_QUOTED_IDENTIFIER expr
      { vector<Expression*> args;
        args.push_back($1); args.push_back($3);
        $$=new Call(@$, $2, args);
        free($2);
      }
    | MZN_NOT expr %prec MZN_NOT
      { $$=new UnOp(@$, UOT_NOT, $2); }
    | MZN_PLUS expr %prec MZN_NOT
      { if ($2->isa<IntLit>() || $2->isa<FloatLit>()) {
          $$ = $2;
        } else {
          $$=new UnOp(@$, UOT_PLUS, $2);
        }
      }
    | MZN_MINUS expr %prec MZN_NOT
      { if ($2->isa<IntLit>()) {
        $2->cast<IntLit>()->v(-$2->cast<IntLit>()->v());
          $$ = $2;
        } else if ($2->isa<FloatLit>()) {
          $2->cast<FloatLit>()->v(-$2->cast<FloatLit>()->v());
          $$ = $2;
        } else {
          $$=new UnOp(@$, UOT_MINUS, $2);
        }
      }

expr_atom_head :
      '(' expr ')'
      { $$=$2; }
    | '(' expr ')' array_access_tail
      { $$=new ArrayAccess(@$, $2, *$4); delete $4; }
    | MZN_IDENTIFIER
      { $$=new Id(@$, $1, NULL); free($1); }
    | MZN_IDENTIFIER array_access_tail
      { $$=new ArrayAccess(@$, new Id(@1,$1,NULL), *$2);
        free($1); delete $2; }
    | MZN_UNDERSCORE
      { $$=new AnonVar(@$); }
    | MZN_UNDERSCORE array_access_tail
      { $$=new ArrayAccess(@$, new AnonVar(@$), *$2);
        delete $2; }
    | MZN_BOOL_LITERAL
      { $$=new BoolLit(@$, $1); }
    | MZN_INTEGER_LITERAL
      { $$=new IntLit(@$, $1); }
    | MZN_FLOAT_LITERAL
      { $$=new FloatLit(@$, $1); }
    | MZN_STRING_LITERAL
      { $$=new StringLit(@$, $1); free($1); }
    | MZN_ABSENT
      { $$=constants().absent; }
    | set_literal
    | set_comp
    | simple_array_literal
    | simple_array_literal array_access_tail
      { $$=new ArrayAccess(@$, $1, *$2);
        delete $2; }
    | simple_array_literal_2d
    | simple_array_literal_2d array_access_tail
      { $$=new ArrayAccess(@$, $1, *$2);
        delete $2; }
    | simple_array_comp
    | simple_array_comp array_access_tail
      { $$=new ArrayAccess(@$, $1, *$2);
        delete $2; }
    | if_then_else_expr
    | if_then_else_expr array_access_tail
      { $$=new ArrayAccess(@$, $1, *$2);
        delete $2; }
    | let_expr
    | call_expr
    | call_expr array_access_tail
      { $$=new ArrayAccess(@$, $1, *$2);
        delete $2; }

array_access_tail :
      MZN_LEFT_BRACKET expr_list MZN_RIGHT_BRACKET
      { $$=$2; }

set_literal :
      '{' '}'
      { $$ = new SetLit(@$, std::vector<Expression*>()); }
    | '{' expr_list '}'
      { $$ = new SetLit(@$, *$2); delete $2; }

set_comp :
      '{' expr '|' comp_tail '}'
      { $$ = new Comprehension(@$, $2, *$4, true);
        delete $4;
      }

comp_tail :
      generator_list
      { $$=new Generators; $$->_g = *$1; $$->_w = NULL; delete $1; }
    | generator_list MZN_WHERE expr
      { $$=new Generators; $$->_g = *$1; $$->_w = $3; delete $1; }

generator_list : generator_list_head comma_or_none

generator_list_head :
      generator
      { $$=new std::vector<Generator>; $$->push_back(*$1); delete $1; }
    | generator_list_head ',' generator
      { $$=$1; $$->push_back(*$3); delete $3; }

generator : 
      id_list MZN_IN expr
      { $$=new Generator(*$1,$3); delete $1; }

id_list : id_list_head comma_or_none

id_list_head :
      MZN_IDENTIFIER
      { $$=new std::vector<std::string>; $$->push_back($1); free($1); }
    | id_list_head ',' MZN_IDENTIFIER
      { $$=$1; $$->push_back($3); free($3); }

simple_array_literal : 
      MZN_LEFT_BRACKET MZN_RIGHT_BRACKET
      { $$=new ArrayLit(@$, std::vector<MiniZinc::Expression*>()); }
    | MZN_LEFT_BRACKET expr_list MZN_RIGHT_BRACKET
      { $$=new ArrayLit(@$, *$2); delete $2; }

simple_array_literal_2d :
      MZN_LEFT_2D_BRACKET simple_array_literal_2d_list MZN_RIGHT_2D_BRACKET
      { $$=new ArrayLit(@$, *$2);
        for (unsigned int i=1; i<$2->size(); i++)
          if ((*$2)[i].size() != (*$2)[i-1].size())
            yyerror(&@2, parm, "syntax error, all sub-arrays of 2d array literal must have the same length");
        delete $2;
      }
    | MZN_LEFT_2D_BRACKET simple_array_literal_2d_list '|' MZN_RIGHT_2D_BRACKET
      { $$=new ArrayLit(@$, *$2);
        for (unsigned int i=1; i<$2->size(); i++)
          if ((*$2)[i].size() != (*$2)[i-1].size())
            yyerror(&@2, parm, "syntax error, all sub-arrays of 2d array literal must have the same length");
        delete $2;
      }

simple_array_literal_2d_list :
      expr_list
      { $$=new std::vector<std::vector<MiniZinc::Expression*> >;
        $$->push_back(*$1);
        delete $1;
      }
    | simple_array_literal_2d_list '|' expr_list
      { $$=$1; $$->push_back(*$3); delete $3; }

simple_array_comp :
      MZN_LEFT_BRACKET expr '|' comp_tail MZN_RIGHT_BRACKET
      { $$=new Comprehension(@$, $2, *$4, false);
        delete $4;
      }

if_then_else_expr :
      MZN_IF expr MZN_THEN expr elseif_list MZN_ELSE expr MZN_ENDIF
      {
        std::vector<Expression*> iexps;
        iexps.push_back($2);
        iexps.push_back($4);
        for (unsigned int i=0; i<$5->size(); i+=2) {
          iexps.push_back((*$5)[i]);
          iexps.push_back((*$5)[i+1]);
        }
        $$=new ITE(@$, iexps,$7);
        delete $5;
      }

elseif_list :
      { $$=new std::vector<MiniZinc::Expression*>; }
    | elseif_list MZN_ELSEIF expr MZN_THEN expr
      { $$=$1; $$->push_back($3); $$->push_back($5); }

quoted_op :
      MZN_EQUIV_QUOTED
      { $$=BOT_EQUIV; }
    | MZN_IMPL_QUOTED
      { $$=BOT_IMPL; }
    | MZN_RIMPL_QUOTED
      { $$=BOT_RIMPL; }
    | MZN_OR_QUOTED
      { $$=BOT_OR; }
    | MZN_XOR_QUOTED
      { $$=BOT_XOR; }
    | MZN_AND_QUOTED
      { $$=BOT_AND; }
    | MZN_LE_QUOTED
      { $$=BOT_LE; }
    | MZN_GR_QUOTED
      { $$=BOT_GR; }
    | MZN_LQ_QUOTED
      { $$=BOT_LQ; }
    | MZN_GQ_QUOTED
      { $$=BOT_GQ; }
    | MZN_EQ_QUOTED
      { $$=BOT_EQ; }
    | MZN_NQ_QUOTED
      { $$=BOT_NQ; }
    | MZN_IN_QUOTED
      { $$=BOT_IN; }
    | MZN_SUBSET_QUOTED
      { $$=BOT_SUBSET; }
    | MZN_SUPERSET_QUOTED
      { $$=BOT_SUPERSET; }
    | MZN_UNION_QUOTED
      { $$=BOT_UNION; }
    | MZN_DIFF_QUOTED
      { $$=BOT_DIFF; }
    | MZN_SYMDIFF_QUOTED
      { $$=BOT_SYMDIFF; }
    | MZN_PLUS_QUOTED
      { $$=BOT_PLUS; }
    | MZN_MINUS_QUOTED
      { $$=BOT_MINUS; }
    | MZN_MULT_QUOTED
      { $$=BOT_MULT; }
    | MZN_DIV_QUOTED
      { $$=BOT_DIV; }
    | MZN_IDIV_QUOTED
      { $$=BOT_IDIV; }
    | MZN_MOD_QUOTED
      { $$=BOT_MOD; }
    | MZN_INTERSECT_QUOTED
      { $$=BOT_INTERSECT; }
    | MZN_PLUSPLUS_QUOTED
      { $$=BOT_PLUSPLUS; }
    | MZN_NOT_QUOTED
      { $$=-1; }

quoted_op_call :
      quoted_op '(' expr ',' expr ')'
      { if ($1==-1) {
          $$=NULL;
          yyerror(&@3, parm, "syntax error, unary operator with two arguments");
        } else {
          $$=new BinOp(@$, $3,static_cast<BinOpType>($1),$5);
        }
      }
    | quoted_op '(' expr ')'
      { int uot=-1;
        switch ($1) {
        case -1:
          uot = UOT_NOT;
          break;
        case BOT_MINUS:
          uot = UOT_MINUS;
          break;
        case BOT_PLUS:
          uot = UOT_PLUS;
          break;
        default:
          yyerror(&@3, parm, "syntax error, binary operator with unary argument list");
          break;
        }
        if (uot==-1)
          $$=NULL;
        else {
          if (uot==UOT_PLUS && ($3->isa<IntLit>() || $3->isa<FloatLit>())) {
            $$ = $3;
          } else if (uot==UOT_MINUS && $3->isa<IntLit>()) {
            $3->cast<IntLit>()->v(-$3->cast<IntLit>()->v());
          } else if (uot==UOT_MINUS && $3->isa<FloatLit>()) {
            $3->cast<FloatLit>()->v(-$3->cast<FloatLit>()->v());
          } else {
            $$=new UnOp(@$, static_cast<UnOpType>(uot),$3);
          }
        }
      }

call_expr :
      MZN_IDENTIFIER '(' ')'
      { $$=new Call(@$, $1, std::vector<Expression*>()); free($1); }
    | quoted_op_call
    | MZN_IDENTIFIER '(' comp_or_expr ')'
      { 
        if ($3->second) {
          yyerror(&@3, parm, "syntax error, 'where' expression outside generator call");
          $$=NULL;
        } else {
          $$=new Call(@$, $1, $3->first);
        }
        free($1);
        delete $3;
      }
    | MZN_IDENTIFIER '(' comp_or_expr ')' '(' expr ')'
      { 
        vector<Generator> gens;
        vector<ASTString> ids;
        for (unsigned int i=0; i<$3->first.size(); i++) {
          if (Id* id = $3->first[i]->dyn_cast<Id>()) {
            ids.push_back(id->v());
          } else {
            if (BinOp* boe = $3->first[i]->dyn_cast<BinOp>()) {
              Id* id = boe->lhs()->dyn_cast<Id>();
              if (id && boe->op() == BOT_IN) {
                ids.push_back(id->v());
                gens.push_back(Generator(ids,boe->rhs()));
                ids = vector<ASTString>();
              } else {
                yyerror(&@3, parm, "illegal expression in generator call");
              }
            } else {
              yyerror(&@3, parm, "illegal expression in generator call");
            }
          }
        }
        if (ids.size() != 0) {
          yyerror(&@3, parm, "illegal expression in generator call");
        }
        ParserState* pp = static_cast<ParserState*>(parm);
        if (pp->hadError) {
          $$=NULL;
        } else {
          Generators g; g._g = gens; g._w = $3->second;
          Comprehension* ac = new Comprehension(@$, $6,g,false);
          vector<Expression*> args; args.push_back(ac);
          $$=new Call(@$, $1, args);
        }
        free($1);
        delete $3;
      }

comp_or_expr :
      expr_list
      { $$=new pair<vector<Expression*>,Expression*>;
        $$->first=*$1; $$->second=NULL;
        delete $1;
      }
    | expr_list MZN_WHERE expr
      { $$=new pair<vector<Expression*>,Expression*>;
        $$->first=*$1; $$->second=$3;
        delete $1;
      }

let_expr :
      MZN_LET '{' let_vardecl_item_list '}' MZN_IN expr %prec PREC_ANNO
      { $$=new Let(@$, *$3, $6); delete $3; }
    | MZN_LET '{' let_vardecl_item_list comma_or_semi '}' MZN_IN expr %prec PREC_ANNO
      { $$=new Let(@$, *$3, $7); delete $3; }
//    | MZN_LET '{' slet_vardecl_item_list '}' MZN_IN expr %prec PREC_ANNO
//      { $$=new SLetExpr(@$, *$3, $6); delete $3; }
//    | MZN_LET '{' slet_vardecl_item_list ',' '}' MZN_IN expr %prec PREC_ANNO
//      { $$=new SLetExpr(@$, *$3, $7); delete $3; }

//slet_vardecl_item_list :
//      slet_vardecl_item
//      { $$=new vector<VardeclExpr*>; $$->push_back($1); }
//    | slet_vardecl_item_list ',' slet_vardecl_item
//      { $$=$1; $$->push_back($3); }

//slet_vardecl_item :
//      MZN_SVAR MZN_INT ':' MZN_IDENTIFIER MZN_EQ expr
//      { $$=new VardeclExpr(@$,TypeInst::svar(@$),$4,$6);
//        free($4);
//      }

let_vardecl_item_list :
      let_vardecl_item
      { $$=new vector<Expression*>; $$->push_back($1); }
    | constraint_item
      { $$=new vector<Expression*>;
        ConstraintI* ce = $1->cast<ConstraintI>();
        $$->push_back(ce->e());
        ce->e(NULL);
      }
    | let_vardecl_item_list comma_or_semi let_vardecl_item
      { $$=$1; $$->push_back($3); }
    | let_vardecl_item_list comma_or_semi constraint_item
      { $$=$1;
        ConstraintI* ce = $3->cast<ConstraintI>();
        $$->push_back(ce->e());
        ce->e(NULL);
      }

comma_or_semi : ',' | ';'

let_vardecl_item :
      ti_expr_and_id annotations
      { $$ = $1;
        $$->toplevel(false);
        if ($2) $$->addAnnotations(*$2);
        delete $2;
      }
    | ti_expr_and_id annotations MZN_EQ expr
      { $1->e($4);
        $$ = $1;
        $$->loc(@$);
        $$->toplevel(false);
        if ($2) $$->addAnnotations(*$2);
        delete $2;
      }

annotations :
      /* empty */
      { $$=NULL; }
    | ne_annotations

ne_annotations :
      MZN_COLONCOLON expr_atom_head
      { $$=new std::vector<Expression*>(1);
        (*$$)[0] = $2;
      }
    | ne_annotations MZN_COLONCOLON expr_atom_head
      { $$=$1; $$->push_back($3); }

id_or_quoted_op :
      MZN_IDENTIFIER
      { $$=$1; }
    | MZN_EQUIV_QUOTED
      { $$=strdup("@<->"); }
    | MZN_IMPL_QUOTED
      { $$=strdup("@->"); }
    | MZN_RIMPL_QUOTED
      { $$=strdup("@<-"); }
    | MZN_OR_QUOTED
      { $$=strdup("@\\/"); }
    | MZN_XOR_QUOTED
      { $$=strdup("@xor"); }
    | MZN_AND_QUOTED
      { $$=strdup("@/\\"); }
    | MZN_LE_QUOTED
      { $$=strdup("@<"); }
    | MZN_GR_QUOTED
      { $$=strdup("@>"); }
    | MZN_LQ_QUOTED
      { $$=strdup("@<="); }
    | MZN_GQ_QUOTED
      { $$=strdup("@>="); }
    | MZN_EQ_QUOTED
      { $$=strdup("@="); }
    | MZN_NQ_QUOTED
      { $$=strdup("@!="); }
    | MZN_IN_QUOTED
      { $$=strdup("@in"); }
    | MZN_SUBSET_QUOTED
      { $$=strdup("@subset"); }
    | MZN_SUPERSET_QUOTED
      { $$=strdup("@superset"); }
    | MZN_UNION_QUOTED
      { $$=strdup("@union"); }
    | MZN_DIFF_QUOTED
      { $$=strdup("@diff"); }
    | MZN_SYMDIFF_QUOTED
      { $$=strdup("@symdiff"); }
    | MZN_DOTDOT_QUOTED
      { $$=strdup("@.."); }
    | MZN_PLUS_QUOTED
      { $$=strdup("@+"); }
    | MZN_MINUS_QUOTED
      { $$=strdup("@-"); }
    | MZN_MULT_QUOTED
      { $$=strdup("@*"); }
    | MZN_DIV_QUOTED
      { $$=strdup("@/"); }
    | MZN_IDIV_QUOTED
      { $$=strdup("@div"); }
    | MZN_MOD_QUOTED
      { $$=strdup("@mod"); }
    | MZN_INTERSECT_QUOTED
      { $$=strdup("@intersect"); }
    | MZN_NOT_QUOTED
      { $$=strdup("@not"); }
    | MZN_PLUSPLUS_QUOTED
      { $$=strdup("@++"); }
