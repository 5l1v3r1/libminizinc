/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */

/*
 *  Main authors:
 *     Guido Tack <guido.tack@monash.edu>
 */

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

%option reentrant
%option bison-bridge bison-locations
%option noyywrap

%{
#if defined __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wdeprecated"
#elif defined _MSC_VER
#pragma warning(push, 1)
#endif

namespace MiniZinc{ class Location; }
#define YYLTYPE MiniZinc::Location
#define YYLTYPE_IS_DECLARED 1
#define YYLTYPE_IS_TRIVIAL 0

#include <minizinc/parser.hh>

int yy_input_proc(char* buf, int size, yyscan_t yyscanner);
#define YY_INPUT(buf, result, max_size) \
  result = yy_input_proc(buf, max_size, yyscanner);

#define YY_USER_ACTION \
  { MiniZinc::ParserState* parm =  \
    static_cast<MiniZinc::ParserState*>(yyget_extra(yyscanner)); \
    yylloc->first_line = yylloc->last_line = parm->lineno; \
  }

long long int strtointval(const char* s) {
#ifdef HAVE_ATOLL
  return atoll(s);
#else
  std::istringstream iss(s);
  long long int v;
  iss >> v;
  return v;
#endif
}

void beginToken(void* parm, YYLTYPE* yyloc, char* t) {
  MiniZinc::ParserState* pp =
    static_cast<MiniZinc::ParserState*>(parm);
  int tokenLength = strlen(t);
  yyloc->first_column = pp->nTokenNextStart;
  pp->nTokenNextStart += tokenLength;
  yyloc->last_column = pp->nTokenNextStart-1;
}

void clearBuffer(void* parm) {
  MiniZinc::ParserState* pp =
    static_cast<MiniZinc::ParserState*>(parm);
  pp->stringBuffer = "";
}

void appendBufferString(void* parm, const char* s) {
  MiniZinc::ParserState* pp =
  static_cast<MiniZinc::ParserState*>(parm);
  pp->stringBuffer += s;
}

void appendBufferChar(void* parm, char s) {
  MiniZinc::ParserState* pp =
  static_cast<MiniZinc::ParserState*>(parm);
  pp->stringBuffer += s;
}

char* bufferData(void* parm) {
  MiniZinc::ParserState* pp =
    static_cast<MiniZinc::ParserState*>(parm);
  return strdup(pp->stringBuffer.c_str());
}

%}

%x string

%%

\n                { MiniZinc::ParserState* parm =
                      static_cast<MiniZinc::ParserState*>(
                        yyget_extra(yyscanner));
                    parm->lineno++;
                    parm->lineStartPos += parm->nTokenNextStart;
                    parm->nTokenNextStart=1;
                  }
[ \f\r\t]         { /* ignore whitespace */
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                  }
"["               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LEFT_BRACKET; }
"[|"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LEFT_2D_BRACKET; }
"]"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_RIGHT_BRACKET; }
"|]"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_RIGHT_2D_BRACKET; }
%.*               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    /* ignore comments */ }

"true"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->iValue = 1; return MZN_BOOL_LITERAL; }
"false"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->iValue = 0; return MZN_BOOL_LITERAL; }
[0-9]+          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->iValue = strtointval(yytext); return MZN_INTEGER_LITERAL; }
0x[0-9A-Fa-f]+  { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->iValue = strtointval(yytext); return MZN_INTEGER_LITERAL; }
0o[0-7]+        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->iValue = strtointval(yytext); return MZN_INTEGER_LITERAL; }
[0-9]+\.[0-9]+  { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->dValue = strtod(yytext,NULL);
                    return MZN_FLOAT_LITERAL; }
[0-9]+\.[0-9]+[Ee][+-]?[0-9]+  {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->dValue = strtod(yytext,NULL);
                    return MZN_FLOAT_LITERAL; }
[0-9]+[Ee][+-]?[0-9]+  {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->dValue = strtod(yytext,NULL);
                    return MZN_FLOAT_LITERAL; }
[:;|{}(),\[\]\.]    { 
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return *yytext; }
\.\.              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DOTDOT; }
"'\.\.'"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DOTDOT_QUOTED; }
::                { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_COLONCOLON; }
_                 { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_UNDERSCORE; }
"ann"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ANN; }
"annotation"      { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ANNOTATION; }
"any"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ANY; }
"array"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ARRAY; }
"bool"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_BOOL; }
"case"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_CASE; }
"constraint"      { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_CONSTRAINT; }
"default"         { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DEFAULT; }
"div"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IDIV; }
"'div'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IDIV_QUOTED; }
"diff"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DIFF; }
"'diff'"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DIFF_QUOTED; }
"else"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ELSE; }
"elseif"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ELSEIF; }
"endif"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ENDIF; }
"enum"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ENUM; }
"float"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_FLOAT; }
"function"        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_FUNCTION; }
"if"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IF; }
"include"         { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_INCLUDE; }
"intersect"       { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_INTERSECT; }
"'intersect'"     { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_INTERSECT_QUOTED; }
"in"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IN; }
"'in'"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IN_QUOTED; }
"int"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_INT; }
"let"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LET; }
"list"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LIST; }
"maximize"        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->bValue = false; return MZN_MAXIMIZE; }
"minimize"        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->bValue = true; return MZN_MINIMIZE; }
"mod"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MOD; }
"'mod'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MOD_QUOTED; }
"not"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_NOT; }
"'not'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_NOT_QUOTED; }
"of"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_OF; }
"output"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_OUTPUT; }
"opt"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_OPT; }
"par"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PAR; }
"predicate"       { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PREDICATE; }
"record"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_RECORD; }
"satisfy"         { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SATISFY; }
"set"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SET; }
"solve"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SOLVE; }
"string"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_STRING; }
"subset"          { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SUBSET; }
"'subset'"        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SUBSET_QUOTED; }
"superset"        { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SUPERSET; }
"'superset'"      { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SUPERSET_QUOTED; }
"svar"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SVAR; }
"symdiff"         { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SYMDIFF; }
"'symdiff'"       { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_SYMDIFF_QUOTED; }
"test"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_TEST; }
"then"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_THEN; }
"tuple"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_TUPLE; }
"type"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_TYPE; }
"union"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_UNION; }
"'union'"         { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_UNION_QUOTED; }
"var"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_VAR; }
"variant_record"  { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_VARIANT_RECORD; }
"where"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_WHERE; }
"xor"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_XOR; }
"'xor'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_XOR_QUOTED; }
"+"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PLUS; }
"'+'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PLUS_QUOTED; }
"-"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MINUS; }
"'-'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MINUS_QUOTED; }
"*"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MULT; }
"'*'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_MULT_QUOTED; }
"/"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DIV; }
"'/'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_DIV_QUOTED; }
"++"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PLUSPLUS; }
"'++'"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_PLUSPLUS_QUOTED; }
"<>"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_ABSENT; }
"<"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LE; }
"'<'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LE_QUOTED; }
"<="              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LQ; }
"'<='"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_LQ_QUOTED; }
">"               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_GR; }
"'>'"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_GR_QUOTED; }
">="              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_GQ; }
"'>='"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_GQ_QUOTED; }
"=="              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQ; }
"'=='"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQ_QUOTED; }
"="               { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQ; }
"'='"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQ_QUOTED; }
"!="              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_NQ; }
"'!='"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_NQ_QUOTED; }
"->"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IMPL; }
"'->'"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_IMPL_QUOTED; }
"<-"              { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_RIMPL; }
"'<-'"            { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_RIMPL_QUOTED; }
"<->"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQUIV; }
"'<->'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_EQUIV_QUOTED; }
"\\/"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_OR; }
"'\\/'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_OR_QUOTED; }
"/\\"             { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_AND; }
"'/\\'"           { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return MZN_AND_QUOTED; }
[A-Za-z][A-Za-z0-9_]* {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->sValue = strdup(yytext); return MZN_IDENTIFIER; }
_[A-Za-z][A-Za-z0-9_]* {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    MiniZinc::ParserState* parm =
                    static_cast<MiniZinc::ParserState*>(yyget_extra(yyscanner));
                    if (parm->isFlatZinc) {
                      yylval->sValue = strdup(yytext); return MZN_IDENTIFIER;
                    } else {
                      return FLATZINC_IDENTIFIER;
                    }
                    }
$[A-Za-z][A-Za-z0-9_]* {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->sValue = strdup(yytext+1); return MZN_TI_IDENTIFIER; }

\"                { BEGIN string; beginToken(yyget_extra(yyscanner), yylloc, yytext); clearBuffer(yyget_extra(yyscanner)); }
<string>[^\\"\n]* { beginToken(yyget_extra(yyscanner), yylloc, yytext); appendBufferString(yyget_extra(yyscanner), yytext); }
<string>\\n         { beginToken(yyget_extra(yyscanner), yylloc, yytext); appendBufferChar(yyget_extra(yyscanner), '\n'); }
<string>\\t         { beginToken(yyget_extra(yyscanner), yylloc, yytext); appendBufferChar(yyget_extra(yyscanner), '\t'); }
<string>\\[\\']     { beginToken(yyget_extra(yyscanner), yylloc, yytext); appendBufferChar(yyget_extra(yyscanner), yytext[1]); }
<string>\\[\\"]     { beginToken(yyget_extra(yyscanner), yylloc, yytext); appendBufferChar(yyget_extra(yyscanner), yytext[1]); }
<string>\"          { beginToken(yyget_extra(yyscanner), yylloc, yytext); yylval->sValue = bufferData(yyget_extra(yyscanner));
                      BEGIN 0; return MZN_STRING_LITERAL; }

`[A-Za-z][A-Za-z0-9_]*` {
                    beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    yylval->sValue = strdup(yytext+1);
                    yylval->sValue[strlen(yytext)-2] = 0; 
                    return MZN_QUOTED_IDENTIFIER; }
.                 { beginToken(yyget_extra(yyscanner), yylloc, yytext);
                    return UNKNOWN_CHAR; }
%%
int yy_input_proc(char* buf, int size, yyscan_t yyscanner) {
  MiniZinc::ParserState* parm = 
    static_cast<MiniZinc::ParserState*>(yyget_extra(yyscanner));
  return parm->fillBuffer(buf, size);
  // work around warning that yyunput is unused
  yyunput (0,buf,yyscanner);
}
